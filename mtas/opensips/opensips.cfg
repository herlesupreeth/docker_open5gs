#
# Copyright (C) 2024 SIP Point Consulting SRL
#
# This file is part of opensips, a free SIP server.
#
# opensips is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version
#
# opensips is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
#
###################################################################################
###################################################################################
#
# OpenSIPS TAS routing logic config written with by Abdul Karim Barbour
# This is not intended for use in commercial projects and is only for educational purposes. Please seek a commercial solution that suits your needs.
# Hope your can learn more about IMS TAS one of the important part of the IMS 
# its is responsible for most of the sublimantry services for the subscribers like Voicemail, call forwarding, announcments ...etc
# Have Fun!
#
###################################################################################


####### Global Parameters #########

log_level = 4
xlog_level=4
stderror_enabled=yes
syslog_enabled=no
syslog_facility=LOG_LOCAL0

udp_workers = 4
tcp_workers = 4

/* uncomment the following lines to enable debugging */
#debug_mode=yes

/* uncomment the next line to enable the auto temporary blacklisting of
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns
   lookup failures (default disabled) */
#dns_try_ipv6=yes

/* comment the next line to enable the auto discovery of local aliases
   based on reverse DNS on IPs */
auto_aliases = no

disable_dns_failover = no

## IDs
server_header="Server: OpenSIPS TAS"
user_agent_header="User-Agent: OpenSIPS TAS"


socket=udp:${OPENSIPS_IP}:5060
socket=tcp:${OPENSIPS_IP}:5060

alias=udp:"mtas.ims.mnc001.mcc001.3gppnetwork.org":5060
alias=tcp:"mtas.ims.mnc001.mcc001.3gppnetwork.org":5060


ifelse(`${ENABLE_HOMER}',`yes',`
socket=hep_udp:${OPENSIPS_IP}:9060
')


####### Modules Section ########

#set module path
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules"

#### HTTPD module
loadmodule "httpd.so"
modparam("httpd", "ip", "${OPENSIPS_IP}")

#### MI_HTTP module
loadmodule "mi_http.so"

#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)

#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 120)
modparam("tm", "wt_timer", 5)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)
modparam("tm", "disable_6xx_block", 1)

#### Record Route Module
loadmodule "rr.so"
modparam("rr", "append_fromtag", 0)
modparam("rr", "enable_double_rr", 1)

#### MAX ForWarD module
loadmodule "maxfwd.so"

#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"

#### TEXT OPerationS module
loadmodule "textops.so"

#### MYSQL module
loadmodule "db_mysql.so"

#### DIALOG Module
loadmodule "dialog.so"
modparam("dialog", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "db_mode", 2)
modparam("dialog", "default_timeout", 21600)  # 6 hours timeout
modparam("dialog", "enable_stats", 1)

#### TOPOLOGY HIDING Module
loadmodule "topology_hiding.so"

#### DOMAINS module
#loadmodule "domain.so"
#modparam("domain", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")
#modparam("domain", "db_mode", 1)

### SQL_OPS module
loadmodule "sqlops.so"
modparam("sqlops", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")

#### USeR LOCation module
loadmodule "usrloc.so"
modparam("usrloc", "working_mode_preset", "single-instance-sql-write-back")
modparam("usrloc", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")
modparam("usrloc", "use_domain", 0)
modparam("usrloc", "timer_interval", 10)
modparam("usrloc", "nat_bflag", "NAT_DST")
modparam("usrloc", "desc_time_order", 1)

#### REGISTRAR module
loadmodule "registrar.so"
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")
modparam("registrar", "received_avp", "$avp(received)")
modparam("registrar", "max_contacts", 10)
modparam("registrar", "max_expires", 3600)

#### NAT Helper module
loadmodule "nathelper.so"
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "received_avp", "$avp(received)")
modparam("nathelper", "sipping_bflag", "NAT_DST")
modparam("nathelper", "sipping_from", "sip:pinger@mtas.${DEFAULT_DOMAIN}")

#### AUTH module
loadmodule "auth.so"
modparam("auth", "nonce_expire",  30)
modparam("auth", "disable_nonce_check", 1)

##### AUTH_DB module
loadmodule "auth_db.so"
modparam("auth_db", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")
modparam("auth_db", "use_domain", 0)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "calculate_ha1", 0)
modparam("auth_db", "load_credentials","$avp(caller_acls)=acls;$avp(caller_cli)=cli;")

#### ACCounting module
loadmodule "acc.so"
modparam("acc", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")
modparam("acc", "extra_fields", "db: caller_ip; caller_ua; callee_ip; callee_ua")
modparam("acc", "leg_fields", "db:  caller_id;
								    callee_id;
									leg_status;
									")

#### DIALPLAN module
loadmodule "dialplan.so"
modparam("dialplan", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")

#### Dynamic ROUTING module
loadmodule "drouting.so"
modparam("drouting", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")

#### Alias-DB module
loadmodule "alias_db.so"
modparam("alias_db", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")

#### UAC module
loadmodule "uac.so"

#### RTP_RELAY module
loadmodule "rtp_relay.so"

#### Core Presence modules
loadmodule "presence.so"
loadmodule "presence_xml.so"
modparam("presence", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")
modparam("presence_xml","force_active",1)

#### XCap parameters
loadmodule "xcap.so"
modparam("xcap", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")

#### Dispatcher module
loadmodule "dispatcher.so"
modparam("dispatcher", "db_url", "mysql://${MYSQL_MTAS_USER}:${MYSQL_MTAS_PASSWORD}@${MYSQL_MTAS_IP}/${MYSQL_MTAS_DATABASE}")
modparam("dispatcher", "ds_ping_from", "sip:ds@PRIV_IP")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_threshhold", 1)
modparam("dispatcher", "options_reply_codes", "404")
modparam("dispatcher", "setid_pvar", "$avp(ds_set)")

#### ConFiG UTILS module
loadmodule "cfgutils.so"

ifelse(`${ENABLE_HOMER}',`yes',`
#### HEP module
loadmodule "proto_hep.so"
modparam("proto_hep", "hep_id", "[hid] ${HOMER_IP}:${HOMER_PORT}; transport=udp; version=3")

#### TRACER module
loadmodule "tracer.so"
modparam("tracer", "trace_on", 1)
modparam("tracer", "trace_id", "[tid] uri=hep:hid")
')

loadmodule "proto_udp.so"
loadmodule "proto_tcp.so"

####### Routing Logic ########


# main request routing logic

route{

	ifelse(`${ENABLE_HOMER}',`yes',`trace("tid", "t", "sip|xlog");')

	xlog("incoming $rm from $si:$sp, From=$fu, To RURI-User=$rU, proccessing in main Routing-Block logic\n");

	force_rport();

	route(handle_pings);

	route(sanity_checks);

	if (has_totag()) {
  xlog("handling hast_tag sequentials\n");
  route(handle_sequentials);
  }
	

  if (is_method("BYE")) {
		# do accounting even if the transaction fails
		do_accounting("log","failed");
	}

		# handle Subscribe/Notify
		if (is_method("SUBSCRIBE|NOTIFY") && is_myself("$rd")) {
			route(handle_presence);
			exit;
		}
   
	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans())
			t_relay();
		exit;
	}
 
	# absorb retransmissions, but do not create transaction
	t_check_trans();

	xlog("finished first checks, proceed handling initial request...\n");


## We are TAS, so we get only 3rd Party registration, AUTH is done on the S-CSCF, WIP : currentlly we provision the User automatically if the user is not found in the DB.

	if (is_method("REGISTER"))
		route(IMS_3RD_PARTY_REG);

    ## write CDR
		route(start_accounting);
    $acc_leg(caller_id) = $fu;
    
	### continue handling requests per method

	$avp(start_ts) = $Ts;

	if (is_method("INVITE"))
	  route(handle_invite);


	if (is_method("SUBSCRIBE|PUBLISH"))
		route(handle_presence);

	send_reply(405, "Method Not Allowed");
	exit;
}

route[handle_pings]
{
	# keepalive notifies replied ok
	if ( is_method("OPTIONS") && !has_totag() && is_myself("$rd") ) {
		send_reply(200, "OK");
		exit;
	}
}


# WIP : more checks could be added, like a trusted list of IP Adresses etc.. 
route[sanity_checks]
{
	if (!mf_process_maxfwd_header(10)) {
		send_reply(483,"Too Many Hops");
		exit;
	}

}

#### Handling Sequestials and routing them depanding on Orig or Term
route[handle_sequentials]
{

  	# handle hop-by-hop ACK (no routing required)
		if (is_method("ACK") && t_check_trans()) {
      xlog("handling ACK\n");
			t_relay();
			exit;
		}
		if (is_method("PRACK|UPDATE")) {
      xlog("handling Sequestial $rm - checking sescase ..\n");
      if ( $(hdr(Route)[0]{param.value,sescase}) == "orig") {
          xlog("Sequestial $rm belongs to Orig Leg\n");
          loose_route();
          route(relay);
      } else 
        if ( $(hdr(Route)[0]{param.value,sescase}) == "term") {
          xlog("Sequestial $rm belongs to Term Leg\n");
          loose_route();
          route(relay_term);
        } else {
         xlog("I dont know to whom Sequestial $rm belongs to, relying it anyway\n");       
			t_relay();
      }
			exit;

    }

		if (!loose_route() ) {
			send_reply(606,"Not Acceptable - no loose route");
			exit;
		}

		xlog("[$ci] routing sequential request to $ru/$du\n");


     xlog("Relaying sequestials method $rm Flag is $mf branch flag is $bf\n");
     route(relay);
     exit;
     
}

route[IMS_3RD_PARTY_REG] {

    # Store original R-URI to Var
    $var(ruri_reg) = $ru;

    append_to_reply("X-Reg: 3rdPty_Register\r\n");
    # Validate required IMS headers
    if ($hdr(P-Associated-URI) == "") {
        xlog("L_ERR", "Missing P-Associated-URI in 3rd-party REGISTER\n");
        sl_send_reply(400, "Bad Request - Missing P-Associated-URI");
        exit;
    }
  

	if ($socket_in(proto)!="UDP")
		setflag("TCP_PERSISTENT");

    # Extract contact information
    $var(contact_uri) = $ct.fields(uri);
    if ($var(contact_uri) == "") {
        xlog("L_ERR", "Failed to extract contact URI from Contact header\n");
        sl_send_reply(400, "Bad Request - Invalid Contact");
        exit;
    }

    # Handle expires value
    $var(expires) = 600;  # Default expiration
    if ($hdr(Expires) != "") {
        $var(expires) = $hdr(Expires);
    } 
    else if ($ct.fields(expires) != "") {
        $var(expires) = $ct.fields(expires);
    }
    
    ## Typically we don't expect IMSI as Public Identity it should be barred and therfore Kamailio ims_isc code avoides sending it in 3rd Party register
    ## We will take for the sake of simplicty the first PAU value and extract the ID from it, we expect it in sip: schema 
    ## WIP: add other IDs to User's Alias but not now :(
    
    if (is_present_hf("P-Associated-URI")) {

        $var(pau_values) = $(hdr(P-Associated-URI)[*]);
        xlog("PAU VALUES are $var(pau_values) \n");

        # Get the first header instance
        $var(header_instance) = $(hdr(P-Associated-URI)[0]);
    
        # Extract the first URI from the header
        $var(uri) = $(var(header_instance){nameaddr.0.uri});
    
        if ($(var(uri){s.len}) > 0) {
        # Process the first URI
            xlog("Processing first associated URI: $var(uri)\n");
            # ... your existing processing code here ...
        } else {
            xlog("WARNING: No valid URI found in P-Associated-URI header\n");
        }

        xlog("PAU VALUES after proccesing are $var(uri) -- $var(uri_current)\n");
    
    ## Check if user exist and enabled on MTAS, as we now have the IMPU, if not then: 
    ## WIP : ether we do auto provision on first register or we let it to OpenSIPS-CP, we will go with AutoProv for now :).
    
    $var(reg_user) = $(var(uri){uri.user});
    $var(reg_user_domain) = $(var(uri){uri.host});
    xlog("[$ci] caller is $var(reg_user) Domain is $var(reg_user_domain)\n");
    
    ## Auto Provision User if not exist, with ACL=E4 //USER_ENABLED; VM_ENABLED//, for managing the ACLs, login to OpenSIPS-CP
    
    sql_query("SELECT username FROM subscriber WHERE username='$var(reg_user)'","$avp(if_usr_exsist)");
    if ($avp(if_usr_exsist) != $var(reg_user)) {
      xlog("User does not exsist $var(reg_user)@$var(reg_user_domain), doing auto Provisioning on 1st Time Register\n");
      sql_insert( 'subscriber', '[{"username":"$var(reg_user)"}, {"domain":"$var(reg_user_domain)"}, {"acls":"E4"}]' );
      
    } else if ($avp(if_usr_exsist) == $var(reg_user)) {
      xlog("User exist under $avp(if_usr_exsist), procceding further with registration proccess\n");
    }

    sql_query("SELECT acls FROM subscriber WHERE username='$var(reg_user)'","$avp(caller_acls)");
	  xlog("[$ci] caller currect ACLs $avp(caller_acls)\n");
  
	  if (!is_acl_set(caller_acls, ACL_ENABLED)) {
	  	xlog("[$ci] registration forbidden for disabled user  $avp(caller_acls)\n");
  	} else if (is_acl_set(caller_acls, ACL_ENABLED)) {
	  	xlog("[$ci] registration allowed for $tU $avp(caller_acls)\n");
      }
   
    ## finnshed getting the ACLs, now procced with saving IMPU if everything is OK
	    		if (!save("location", "path-lazy, no-reply", $var(uri))) {
          xlog("L_ERR", "Failed to save contact for IMPU: $var(uri)\n");
          t_reply(503, "Internal Error");
          exit;
			} else {
          xlog("L_INFO", "Saved contact for IMPU: $var(uri)\n");
           append_to_reply("Contact: $var(ruri_reg)\r\n");
           append_to_reply("Expires: $var(expires)\r\n");
          sl_send_reply(200, "OK 3rd-Party REGISTER");
          exit;
				ul_add_key("location", "$tU@$td", "identities", "$var(uri)");
			  }
		  }
}

route[handle_invite]
{
	if (!create_dialog("B")) {
		xlog("L_ERR", "cannot create dialog!\n");
		send_reply(500, "Server Internal Error");
		exit;
	}
 
   ##  checking if this is a Orig or Term Call, 3GPP sescase=orig,term determain the session case for TAS, some implementations use call=orig,term in Route, we check both if one of them orig or term:

   $var(call_sescase) = $(hdr(Route)[0]{param.value,call});
   $var(reg_state) = $(hdr(P-Served-User){param.value,regstate});
   $var(ses_case) = $(hdr(P-Served-User){param.value,sescase});
   if ($var(call_sescase) == "orig" || $var(ses_case = "orig")) {
      xlog("call session case is: $var(ses_case) -- Reg-State is: $var(reg_state)\n");
    
    ### Check if Orig User is registred- WIP:  we could move this check to Orig logic, but we leave it for now here.

    is_registered("location",$fu); 
    switch ($retcode) {
        case 1:
        xlog("Orig User found and registered, Now handle_orig\n");
        $ru = $tu;
        xlog("Orig $rm from $fu to $rU and RURI is $ru, proccessing in handle_dialplan_orig\n");
        record_route(";sescase=orig");
        xlog("Setting flags on Orig\n");
		    setbflag("INITIAL_INVITE");
       	t_on_reply("reply_handler"); 
        route(handle_dialplan_orig);
        case -1:
            sl_send_reply(404, "Orig User Not registered"); ### WIP : we could look in the DB if the user exist but not registered, then reply with more approcriate code
            exit;
        }
    }
   if ($var(call_sescase) == "term" || $var(ses_case = "term")) {
      xlog("call Session case is Term and Reg-State is: $var(reg_state), proccessing in term_user\n");
      record_route(";sescase=term");
      xlog("Setting flags on term\n");
		  setbflag("INITIAL_INVITE_TERM");
     	t_on_reply("reply_handler_term");       
      route(term_user);
    }


    if ($var(call_sescase) == NULL) {
      xlog("call type is Unknown\n");
      sl_send_reply(403, "Unknown call session case");
    }
  exit;
}


route[handle_dialplan_orig]
{

### WIP : we need to look at how we can utilze the Dialplan to most benificial way, and do more Orig Services.
    
    xlog("L_INFO", "[$ci] Received Orig INVITE for $fU calling to $tU - starting Dialplan proccess ($ru/$du)\n");

    xlog("building SIP R-URI for later user in case needed\n");
    $var(sip_ruri) = "sip:" + $tU + "@" + $fd + ";user=phone" + ";phone-context=" + $fd;
    xlog("Resulting SIP R-URI is $var(sip_ruri)\n");

	while ([1]) {

	# apply dialplan
    xlog("[$ci] applying dialplan on <$rU>\n");

		$var(dp_type) = NULL;

		if (!dp_translate(1, $tU, $ru, $var(dp_type))) {
			xlog("R-URI <$rU> not recognized by dialplan\n");
			send_reply(404,"Dialplan Pattern not recognized");
			exit;
		}

		xlog("[$ci] dialled number translated to <$rU> @ <$rd>, "
			"type $var(dp_type)\n");

		if ($var(dp_type)==NULL || $var(dp_type)=="") {
			xlog("provisioning BUG in dialplan, type is not valid\n");
			send_reply(404,"Dialplan Type Not Found");
			exit;
		}

		switch( $var(dp_type) ) {

			case "DP_DID":

				if (!alias_db_lookup("dids")) {
					## Route back after record route and remove ourselves from firsr route to IMS
					route(to_ims);
					exit;
				}
				# continue translating the new URI
				break;

			case "DP_USER":  ## WIP : the Plan here is to execute aktivation of orig services for Orig user, like actiavte CFx/TIR/TIP ..etc
				route(orig_user);
				break;

#### checking if user want to activate any originating Services 

			case "DP_DND_ON":
				## call to DND
				route( handle_starcode, "DND_ON");
				break;

			case "DP_DND_OFF":

				## call to DND
				route( handle_starcode, "DND_OFF");
				break;

			case "DP_VMLISTEN":

				## Call to voicemail for listening messages
        remove_hf("Route");
				route(listen_voicemail);
				break;

			case "DP_VM":
  			## activate/decativate CF_VM
        if ($rU == "*22*5") {
				route( handle_starcode, "CF_VMA");
        } else
        if ($rU == "*22*7") {
        route( handle_starcode, "CF_VMB");
        } else
        if ($rU == "*22*8") {
        route( handle_starcode, "CF_VMNA");
        } else
        if ($rU == "*22*0") {
        route( handle_starcode, "CF_VM_OFF");
        } else {
        send_reply(404,"Wrong VM Code");
        }
				break;

			case "DP_OIR":
  			## activate/decativate OIR (Originating Identification Restriction)
        if ($rU == "*31*1") {
				route( handle_starcode, "OIR_ON");
        } else
        if ($rU == "*31*2") {
        route( handle_starcode, "OIR_OFF");
        } else {
        send_reply(404,"Wrong CLIR activation Code");
        }

				break;
			case "DP_TIR":
  			## activate/decativate TIR (Terminating Identification Restriction)
        if ($rU == "*77*1") {
				route( handle_starcode, "TIR_ON");
        } else
        if ($rU == "*77*2") {
        route( handle_starcode, "TIR_OFF");
        } else {
        send_reply(404,"Wrong CLIR activation Code");
        }
				break;
                
			case "DP_CFNA":
  			## activate/deactivate CFNA
        $var(cfna_uri) = $(ru{uri.user});
        if ($var(cfna_uri) == "*61*") {
        route( handle_starcode, "CFNA_OFF");
        }
        if ($var(cfna_uri) =~ "^\\*61\\*") {
        $var(cfna_des) = $(var(cfna_uri){s.select,2,*});
        $var(cfna_timer) = $(var(cfna_uri){s.select,3,*});
        route( handle_starcode, "CFNA_ON");
        } else {
        send_reply(404,"Wrong CFNA Code");
        }
				break;

			case "DP_CFB":
  			## activate/deactivate CFB
        $var(cfb_uri) = $(ru{uri.user});
        if ($var(cfna_uri) == "*67*") {
        route( handle_starcode, "CFB_OFF");
        }
        if ($var(cfna_uri) =~ "^\\*67\\*") {
        $var(cfb_des) = $(var(cfna_uri){s.select,2,*});
        route( handle_starcode, "CFB_ON");
        } else {
        send_reply(404,"Wrong CFB Code");
        }
				break;

			case "DP_CFU":
  			## activate/deactivate CFU
        $var(cfu_uri) = $(ru{uri.user});
        if ($var(cfu_uri) == "*21*") {
        route( handle_starcode, "CFU_OFF");
        }
        if ($var(cfu_uri) =~ "^\\*21\\*") {
        $var(cfu_des) = $(var(cfu_uri){s.substr,4,0});
        route( handle_starcode, "CFU_ON");
        }
				break;
        

			default:

				xlog("[$ci] provisioning BUG in dialplan, type $var(dp_type) "
					"is not supported\n");
				send_reply(404,"Unknown Dialplan Pattern");
				exit;

		} /* switch */

	} /* while */

	# end (not ever reached)
}


route[handle_dialplan_term]
{

### Term to User : WIP : the Idea here is to execute terminating services ( Callcenters, IVRs, etc..) 
### We could also excute Sh Diameter to HSS to get user Profile and active services line CFx, but this will be in later step

	# apply dialplan
    xlog("[$ci] applying dialplan on Term-Leg\n");

	while ([1]) {

		$var(dp_type) = NULL;

		if (!dp_translate(1, $rU, $rU, $var(dp_type))) {
			xlog("[$ci] local username <$rU> not recognized by dialplan\n");
			send_reply(404,"Not Found");
			exit;
		}

		xlog("[$ci] dialled number translated to <$rU> @ <$rd>, "
			"type $var(dp_type)\n");

		if ($var(dp_type)==NULL || $var(dp_type)=="") {
			xlog("[$ci] provisioning BUG in dialplan, type is not valid\n");
			send_reply(404,"Not Found");
			exit;
		}

		switch( $var(dp_type) ) {

			case "DP_DID":

				if (!alias_db_lookup("dids")) {
					## route to term User for Terminating services
					route(term_user);
					exit;
				}
				# continue translating the new URI
				break;

			default:

				xlog("[$ci] provisioning BUG in dialplan, type $var(dp_type) "
					"is not supported\n");
				send_reply(404,"Unknown Dialplan Pattern");
				exit;

		} /* switch */

	} /* while */

	# end (not ever reached)
}


# Send to IMS : WIP -- we dont do some match things here as we rely the call now to IMS, so the IMS can do his job and find us on the other Side ( Term Side not Star side)
route[to_ims]
{

  if (!isflagset("CF_INVITE")) {
	$acc_leg(callee_id) = $var(sip_ruri);
	xlog("translation finnished - routing to <$ru> from $acc_leg(caller_id) through IMS\n");
   }

  if (isflagset("CF_INVITE")) {
	xlog("is CF_INVITE - routing to <$ru> from $acc_leg(caller_id) through IMS\n");
   }
  t_on_failure("orig_call");
#### The Idea is to apply the activated Originating services like (OIP/OIR/CLIPnS ..etc) here before we send it back to the S-CSCF so its now WIP ;(
  loose_route();
	route(relay_initial);
}

route[orig_user] ### WIP : plan is to have some funny orig services like hearing the time ...etc, curretlly this route will not be excuted, we will make sure of it ;)
{

    # Convert R-URI to Tel URI
		if ($ru =~ "^sip:") {
			$var(tel_user) = $rU;
			$var(tel_domain) = $(ru{uri.param,phone-context});
			$ru = "tel:" + $var(tel_user);
		} 
    if (loose_route()) {
			xlog("L_INFO", "Received Orig INVITE for $tu - relaying to S-CSCF ($ru/$du)\n");
   	 t_relay();
    }

}

route[term_user]
{

		if (is_method("PRACK") && has_totag() && t_check_trans()) {
      xlog("handling PRACK\n");
			t_relay();
			exit;
		}
	# routing to user
	xlog("[$ci] proccessing routing to term user <$ru>, checking active terminating servcies\n");

	$avp(callee_acls) := NULL;
	$avp(callee_cfaw_uri) := NULL;
	$avp(callee_cfbs_uri) := NULL;
	$avp(callee_cfna_uri) := NULL;
  $avp(callee_cfna_timer) := NULL;
	$avp(callee_cfnf_uri) := NULL;
	$avp(oir) := NULL;
	$avp(tir) := NULL;

	$var(rc) = sql_query_one("select acls, cfaw_uri, cfbs_uri, cfna_uri, cfna_timer, cfnf_uri, oir, tir from subscriber where username='$rU' and domain='$rd'",
		"$avp(callee_acls), $avp(callee_cfaw_uri), $avp(callee_cfbs_uri), $avp(callee_cfna_uri),$avp(callee_cfna_timer), $avp(callee_cfnf_uri), $avp(oir), $avp(tir)");
	if ( $rc<0 || $avp(callee_acls)==NULL) {
		xlog("[$ci] failed to load profile for user <$rU@$rd>\n");
		# WIP: in this case we plan later to route it to MRF for approcirate announcment.
    send_reply( 404, "User Not Found");
		exit;
	}

	xlog("[$ci] profile for <$tU> loaded acls=<$avp(callee_acls)>,  cfaw_uri=<$avp(callee_cfaw_uri)>, cfbs_uri=<$avp(callee_cfbs_uri)>, cfna_uri=<$avp(callee_cfna_uri) timer $avp(callee_cfna_timer)>, cfnf_uri=<$avp(callee_cfnf_uri)> OIR status: $avp(oir) TIR Status: $avp(tir)\n");

	$acc_leg(callee_id) = $ru;

	# is permanent Call Forward enabled?
	if ($avp(callee_cfaw_uri)!=NULL) {
		route( do_call_forward, $avp(callee_cfaw_uri) );
		# if CF fails, we will continue
	}

	# is Call Forward no answer enabled?
	if ($avp(callee_cfna_uri)!=NULL) {
		# we set the variables for CFNA URI and timer
     # now printing it to console for debug reasons and beacause its just nice to have it there!
     xlog("for called Number $tU there is active CFNA to $avp(callee_cfna_uri) with timer of $var(callee_cfna_timer) seconds\n");
     # now continue the logic, our magic is not here its below in route and t_on_failure_route ;) 
	}

	if (is_acl_set(callee_acls, ACL_VM_ALWAYS)) {
		xlog("[$ci] user had the permanent VM redirect\n");
		route( redirect_to_voicemail );
		t_reply(480, "VM is Unavailable");
		exit;
	}

	# is DND ACL on?
	if (is_acl_set(callee_acls, ACL_DND)) {
		xlog("[$ci] user had the DND turned on, rejecting\n");
		route( redirect_to_voicemail );
		# if no VM, we will continue; WIP: plan to set MRF announcment with DND
		t_reply(486, "Busy Here");
		exit;
	}

	xlog("[$ci] routing to registered AOR <$rU@$rd>\n");

    if (!is_registered("location",$tu)) {
        xlog("Term User not registered, checking CFnR and CF_VM\n");
		      if ($avp(callee_cfnf_uri)!=NULL) {
			        route( do_call_forward, $avp(callee_cfnf_uri) );
		      }
		      if (is_acl_set(callee_acls, ACL_VM_NOT_FOUND)) {
			        route( redirect_to_voicemail );
			    # if no VM, we will continue
		      }
          $ru = "sip:AN_notavailable@${MTAS_MRF}";
          route(to_mediaserver);
          exit;
        }     
   
	t_on_failure("missed_call");

  loose_route();
	route(relay_initial_term);
}

################### Voicemail/MRF handling related routes #####################
route[to_mediaserver]
{
  if ( !topology_hiding_match() && !loose_route() ) {
			send_reply(404,"Not here");
			exit;
  }
  
	$rd = "${MTAS_MRF}";
	$rp = 5090;
	ruri_del_param("transport");
	setbflag("MEDIA_DST");
  t_on_reply("reply_mrf");
	route(relay_initial_mrf);
}

route[relay_initial_mrf]
{
	if (is_method("INVITE")) {
		setflag("MRF_INVITE");
	}
	route(relay_mrf);
}
route[relay_mrf] {

	xlog("[$ci] handling in relay_mrf\n");
	if (!t_relay()) {
		send_reply(500,"Internal Server Error - Unable to rely");
	}
	exit;
	t_relay();

}
onreply_route[reply_mrf]
{
	xlog("[$ci] proccessing reply from MRF\n");

		if ( t_check_status("180|183") && has_body("application/sdp")) {
   	    xlog("[$ci] proccessing/authorizing early media from MRF\n");
        append_hf("P-Early-Media: sendonly\r\n");
		}


}
#### end of MRF Route-Logic
route[redirect_to_voicemail]
{
	xlog("[$ci] caller $acc_leg(caller_id) leaving message for "
		"callee <$acc_leg(callee_id)>\n");

	if ( !is_acl_set(callee_acls, ACL_VM_ENABLED) ) {
		xlog("[$ci] callee does not have the VM service enabled\n");
		return;
	}

	$ru = $acc_leg(callee_id);
	prefix("VM_LV_");

	xlog("[$ci] leaving message for VM BOX $ru\n");

	$acc_leg(callee_id) = $ru;

	route(to_mediaserver);
	# does not return
}


route[listen_voicemail]
{
	# the caller leg is the party dialling
	# to listen/manage the recordings of a vmbox


	xlog("[$ci] caller $acc_leg(caller_id) listening his vmbox\n");

    ## Asking the DB what ACLs does this Subscriber has ?
    sql_query("SELECT acls FROM subscriber WHERE username='$fU'","$avp(caller_acls)");
		xlog("[$ci] caller currect ACLs $avp(caller_acls)\n");

	if ( !is_acl_set(caller_acls, ACL_VM_ENABLED) ) {
		    xlog("[$ci] caller does not have the VM service enabled\n");
	    	send_reply(404,"VM not found");
		    exit;
	}

      xlog("creating a SIP R-URI for Voicemail\n");
      $ru = $var(sip_ruri);

	    #$ru = $acc_leg(caller_id);
	    prefix("VM_LT_");

	    xlog("[$ci] listening message for VM BOX $rU\n");

	    $acc_leg(callee_id) = $ru;

    	route(to_mediaserver);
	# does not return
}


################### StarCodes related routes #####################
route[handle_starcode]
{
	xlog("[$ci] handling star code $param(1) from $acc_leg(caller_id) to RURI=$ru RURI-User=$rU\n");

	# takes one mandatory param which is the name of STAR CODE
	if ($param(1) == "DND_ON") {

		# set DND
		sql_query("update subscriber set acls=concat(REPLACE(acls,'ACL_DND',''),'ACL_DND') where username='$(acc_leg(caller_id){uri.user})' and domain='$(acc_leg(caller_id){uri.host})'");
      if  ($retcode == -1) {
          xlog("L_INFO", "SQL Query retured $retcode error\n");
          send_reply(500, "SQL Querry returned Error");
          exit;
      } else {
	    	$ru = "sip:ANN_SERVICE_SET_DND@${MTAS_MRF}";
      }
	} else
	if ($param(1) == "DND_OFF") {

		# reset DND
		sql_query("update subscriber set acls=REPLACE(acls,'ACL_DND','') where username='$(acc_leg(caller_id){uri.user})' and domain='$(acc_leg(caller_id){uri.host})'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
		        $ru = "sip:ANN_SERVICE_RESET_DND@${MTAS_MRF}";
          }
	} else
	if ($param(1) == "OIR_ON") {

		# enable OIR 
          sql_query("update subscriber
                     SET oir = 'true'
                     WHERE username = '$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
		        $ru = "sip:ANN_SERVICE_OIR_SET@${MTAS_MRF}";
          }
	} else
	if ($param(1) == "OIR_OFF") {

		# disable OIR
          sql_query("update subscriber
                     SET oir = 'false'
                     WHERE username = '$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
		        $ru = "sip:ANN_SERVICE_OIR_UNSET@${MTAS_MRF}";
          }
	} else
	if ($param(1) == "TIR_ON") {

		# enable TIR
          sql_query("update subscriber
                     SET tir = 'true'
                     WHERE username = '$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
          $ru = "sip:ANN_SERVICE_TIR_SET@${MTAS_MRF}";
          }
	} else
	if ($param(1) == "TIR_OFF") {

		# disable TIR
          sql_query("update subscriber
                     SET tir = 'false'
                     WHERE username = '$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
		        $ru = "sip:ANN_SERVICE_TIR_UNSET@${MTAS_MRF}";
          }
  } else
  
  # turn off CFNA 
	if ($param(1) == "CFNA_OFF") {
          xlog("L_INFO", "de-activating CFNA for Subscriber $fU\n"); # we reset the timer to DEFAULT value of the SQL Colume ( per default its 120)
          sql_query("update subscriber
                     SET cfna_uri = NULL,
                         cfna_timer = DEFAULT
                     WHERE username = '$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
          $ru = "sip:ANN_SERVICE_CFNA_UNSET@${MTAS_MRF}";
          }
  } else
  
  # turn on CFNA 
	if ($param(1) == "CFNA_ON") {
          if ( $var(cfna_timer) > 120) { # set the max limit to 2 minutes, no one want his phone to ring more than that or?
              send_reply(405, "CFNA Timer is not acceptable");
              exit;
          } else {
          $var(cfna_ruri) = "tel:" + $var(cfna_des) + ";phone-context=" + $fd;
          xlog("L_INFO", "Activating CFU to $var(cfna_ruri) for Subscriber $fU after $var(cfna_timer) seconds\n");
          sql_query("update subscriber
                     SET cfna_uri = '$var(cfna_ruri)',
                         cfna_timer = '$var(cfna_timer)'
                     WHERE username = '$fU'");
          }
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {                         
          $ru = "sip:ANN_SERVICE_CFNA_SET@${MTAS_MRF}";
          }
  } else
  
  # turn off CFB
	if ($param(1) == "CFB_OFF") {
          xlog("L_INFO", "de-activating CFB for Subscriber $fU\n");
          sql_query("update subscriber
                     SET cfbs_uri = NULL
                     WHERE username = '$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
          $ru = "sip:ANN_SERVICE_CFB_UNSET@${MTAS_MRF}";
          }
  } else
  
  # turn on CFB
	if ($param(1) == "CFB_ON") {
          $var(cfb_ruri) = "tel:" + $var(cfb_des) + ";phone-context=" + $fd;
          xlog("L_INFO", "Activating CFB to $var(cfb_ruri) for Subscriber $fU\n");
          sql_query("update subscriber
                     SET cfbs_uri = '$var(cfb_ruri)'
                     WHERE username = '$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {                         
          $ru = "sip:ANN_SERVICE_CFB_SET@${MTAS_MRF}";
          }
  } else

  # turn on CFU 
	if ($param(1) == "CFU_ON") {
          $var(cfu_ruri) = "tel:" + $var(cfu_des) + ";phone-context=" + $fd;
          xlog("L_INFO", "Activating CFU to $var(cfu_ruri) for Subscriber $fU\n");
          sql_query("update subscriber
                     set cfaw_uri='$var(cfu_ruri)'
                     where username='$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
          $ru = "sip:ANN_SERVICE_CFU_SET@${MTAS_MRF}";
          }
  } else

  # turn off CFU 
	if ($param(1) == "CFU_OFF") {          
          xlog("L_INFO", "Dectivating CFU for Subscriber $fU\n");
          sql_query("update subscriber
                     set cfaw_uri=NULL 
                     where username='$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
          $ru = "sip:ANN_SERVICE_CFU_UNSET@${MTAS_MRF}";
          }
  } else

  # turn on CFU VM	
  if ($param(1) == "CF_VMA") {
         xlog("$rU Activating CF VM ALWAYS for Subscriber $fU\n");
         sql_query("update subscriber set acls=concat(REPLACE(acls,'ACL_VM_ALWAYS',''),'ACL_VM_ALWAYS') where username='$fU'");
          if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
          } else {
        $ru = "sip:ANN_SERVICE_CFVM_U_SET@${MTAS_MRF}";
        }
	} else
  # turn off CFB VM  
	if ($param(1) == "CF_VMB") {
 
        xlog("L_INFO", "Activating CF VM BUSY for Subscriber $fU\n");
		    sql_query("update subscriber set acls=concat(REPLACE(acls,'ACL_VM_BUSY',''),'ACL_VM_BUSY') where username='$fU'");
        if  ($retcode == -1) {
              xlog("L_INFO", "SQL Query retured $retcode error\n");
              send_reply(500, "SQL Querry returned Error");
              exit;
        } else {
        $ru = "sip:ANN_SERVICE_CFVM_BUSY_SET@${MTAS_MRF}";
        }
	} else
  # turn off CFNA VM  
	if ($param(1) == "CF_VMNA") {      

        xlog("L_INFO", "Activating CF VM NO ANSWER for Subscriber $fU\n");
		    sql_query("update subscriber set acls=concat(REPLACE(acls,'ACL_VM_NO_ANSWER',''),'ACL_VM_NO_ANSWER') where username='$fU'");
        if  ($retcode == -1) {
             xlog("L_INFO", "SQL Query retured $retcode error\n");
             send_reply(500, "SQL Querry returned Error");
             exit;
        } else {                 
        $ru = "sip:ANN_SERVICE_CFVM_NA_SET@${MTAS_MRF}";
        }
	} else
  # turn off all CF VM Type  
	if ($param(1) == "CF_VM_OFF") {

        xlog("L_INFO", "Deactivating all CF VM for Subscriber $fU\n");
		    sql_query("update subscriber SET acls = REPLACE(REPLACE(REPLACE(acls, 'ACL_VM_ALWAYS', ''), 'ACL_VM_BUSY', ''), 'ACL_VM_NO_ANSWER', '') where username='$fU'");
        if  ($retcode == -1) {
             xlog("L_INFO", "SQL Query retured $retcode error\n");
             send_reply(500, "SQL Querry returned Error");
             exit;
        } else {
        $ru = "sip:ANN_SERVICE_CFVM_UNSET@${MTAS_MRF}";
        }
  
  } else {

		xlog("[$ci] configuration error - unsupported star code\n");
		t_reply(404,"Unknown service");
		exit;

	}

	route(to_mediaserver);
	exit;
}

### WIP : we could do some leg based logic after we set flags to INVITE Direction, but we will do it later, last try went horriblly wrong ;(
################### Relaying related routes Orig #####################
### First Orig Leg
route[relay_initial]
{

	xlog("[$ci] handling in relay_initial_orig\n");

	if (is_method("INVITE")) {
 	    xlog("Setting flags\n");
		setbflag("INITIAL_INVITE");

	}
# checking originating services like OIP/OIR ..etc

#lets check if the orig user wishes to hide his ideentity 
  $avp(caller_oir) := NULL;
  sql_query("SELECT oir FROM subscriber WHERE username='$fU'","$avp(caller_oir)");
  if ( $avp(caller_oir) == "true") {
      xlog("Orig User wishes Privacy to his call\n");
      append_hf("Privacy:user;id\r\n");
  }

	route(relay);
}


route[relay] {

	xlog("[$ci] handling in relay_orig\n");
	if (!t_relay()) {
		send_reply(500,"Internal Server Error - Unable to rely");
	}
	exit;

	#t_on_reply("reply_handler"); ##moved to on term/orig excution 

	t_relay();

}

onreply_route[reply_handler]
{
	xlog("[$ci] reply received on Orig <$rm:$rs:$rr> on branch $T_branch_idx\n");


	if (isbflagset("INITIAL_INVITE")) {
		# collect accounting data
		if ( $rs >= 200 ) {
			$acc_extra(callee_ip)= $socket_in(proto)+":"+$si+":"+$sp;
			if (is_present_hf("User-Agent"))
				$acc_extra(callee_ua)=$(hdr(User-Agent));
			else if (is_present_hf("Server"))
				$acc_extra(callee_ua)=$(hdr(Server));
			else $acc_extra(callee_ua)=NULL;
		}

	}
}
### now handling relays on term leg
route[relay_initial_term]
{

	xlog("now handling in relay_initial_term\n");

	if (is_method("INVITE")) {
 	    xlog("Setting flags Term\n"); 
		setbflag("INITIAL_INVITE_TERM");

	}
	route(relay_term);
}


route[relay_term] {

	xlog("[$ci] handling in relay_term\n");
	if (!t_relay()) {
		send_reply(500,"Internal Server Error - Unable to rely");
	}
	exit;
	#t_on_reply("reply_handler_term");
	t_relay();

}

onreply_route[reply_handler_term]
{
	xlog("[$ci] reply received on Term <$rm:$rs:$rr> on branch $T_branch_idx\n");


	if (isbflagset("INITIAL_INVITE_TERM")) {
    if (t_check_status("180|183") && $avp(callee_cfna_uri)!=NULL) {
    xlog("180 or 183 provisional reply - setting Timer accrording to CFNA Timer: $avp(callee_cfna_timer)\n");
      $T_fr_timeout= $avp(callee_cfna_timer);
      $T_fr_inv_timeout = $avp(callee_cfna_timer);
    } else
    if (t_check_status("180|183") && $avp(callee_cfna_uri)==NULL) {
    xlog("180 or 183 provisional reply - setting Timer accrording to default Timer: $avp(callee_cfna_timer)\n");
      $T_fr_timeout=NULL;
      $T_fr_inv_timeout=NULL;
    }
    # check of the terminating User has TIR active
    if (t_check_status("18[0-9]|200") && $avp(tir)=="true") {
        xlog("Terminating user wishes to hide his terminating Identitiy\n");
        append_hf("Privacy:user;id\r\n");
    }    
		# collect accounting data
		if ( $rs >= 200 ) {
			$acc_extra(callee_ip)= $socket_in(proto)+":"+$si+":"+$sp;
			if (is_present_hf("User-Agent"))
				$acc_extra(callee_ua)=$(hdr(User-Agent));
			else if (is_present_hf("Server"))
				$acc_extra(callee_ua)=$(hdr(Server));
			else $acc_extra(callee_ua)=NULL;
		}

	}
}

failure_route[missed_call]
{
	xlog("[$ci] Term call failed to established with $T_reply_code code\n");

	# redirect in case of busy
	if ($T_reply_code == 486 || $T_reply_code == 603) {
		xlog("[$ci] try on busy redirect\n");
		# ok, user is busy, check CF and VM options, from my experince users prefere first to forward to VM, so we first check if CFB VM active otherwise we forward to the configured CFB URI
		if (is_acl_set(callee_acls, ACL_VM_BUSY)) {
			route( redirect_to_voicemail );
			# if no VM, we will continue
		}
		if ($avp(callee_cfbs_uri)!=NULL) {
			route( do_call_forward, $avp(callee_cfbs_uri) );
      # forwarding to confiured CFB URI
		}

	}

	# redirect in timeout / no answer same as above, first CFNA VM then normal CFNA
	else
	if ($T_reply_code == 408) {
		xlog("[$ci] try on no-answer redirect\n");
		# ok, user not answering, check CF and VM options
		if (is_acl_set(callee_acls, ACL_VM_NO_ANSWER)) {
			route( redirect_to_voicemail );
			# if no VM, we check configured CFNA URI 
		} else
		if ($avp(callee_cfna_uri)!=NULL) {
			route( do_call_forward, $avp(callee_cfna_uri) );
		}
	  # if neither CFNA VM nur CFNA confígured then reply with the suitable error 
    # WIP : the plan here is to generate an annoucnment, maybe later :(
  }

	if (t_check_status("30[12]")) {
		send_reply(486, "Busy");
		exit;
	}
}
#### Failure Route for Orig WIP: the idea is to play on Orig side a suitable announcment from the MRF
failure_route[orig_call]
{
		xlog("Testing failure_route for Orig\n");
}   
################### Call Forward related routes #####################


route[do_call_forward]
{
	# expects :
	#  param 1 - new SIP URI

	xlog("[$ci] call forwarding for <$acc_leg(callee_id)> to <$param(1)>\n");

	$ru = $param(1);
	xlog("resulting CFx R-URI is : $ru\n");
	$acc_leg(leg_status) = "redirected_"+$acc_current_leg;

	acc_new_leg();

	# move the acls
	$avp(caller_acls) := $avp(callee_acls);
	$avp(callee_acls) = NULL;

	$acc_leg(leg_status) = "established";

	# previous callee is the new caller
	$acc_leg(caller_id) = $(acc_leg(callee_id)[-2]);

  ## we route back to IMS as we dont know where the user is
  setflag("CF_INVITE");
	route(to_ims);
	# this does not return

	exit;
}


################### Presence related routes #####################

route[handle_presence]
{
	if (!t_newtran()){
		sl_reply_error();
		exit;
	}
	
	# MWI is handled by external Media Server
	if ($hdr(Event)=="message-summary") {
		if (!has_totag()) {
			xlog("[$ci] user <$fu> subscribing to MWI <$ru>\n");
			record_route();
			route(to_mediaserver);
			exit;
		}
		if (!loose_route()) {
			send_reply(487,"Transaction/Leg Does not exists");
			exit;
		}
		route(relay);
		exit;
	}

	# handle local events
	if ($hdr(Event)!="presence") {
		send_reply(489,"Bad Event");
		exit;
	}

	if (is_method("PUBLISH")) {
		handle_publish();
	} else
	if (is_method("SUBSCRIBE")) {
		handle_subscribe();
	}

	exit;
}


################### Accounting related routes #####################

route[start_accounting]
{
	if (!is_method("INVITE"))
		return;

	do_accounting("db", "cdr|failed");

	$acc_leg(leg_status) = "established";

	$acc_extra(caller_ip)= $socket_in(proto)+":"+$si+":"+$sp;

	if (is_present_hf("User-Agent"))
		$acc_extra(caller_ua)=$(hdr(User-Agent));
	else if (is_present_hf("Server"))
		$acc_extra(caller_ua)=$(hdr(Server));
}


